(defpackage #:lexer-test
  (:use #:cl #:lazy-list #:lexer #:small-tests))

(in-package #:lexer-test)

(defmacro def-lexer-test (name grammar str &rest forms)
  `(deftest ,name
     (let ((result (lexer ,grammar (make-string-input-stream ,str))))
       (levery (lambda (get exp) (assert (equal get exp)))
               result ',forms))))

(deflexer test-lex1
  (word (:+ (:r #\a #\z)))
  (whitespace (:or #\Space #\Newline #\Return) :skip t))

(def-lexer-test lexer.1 'test-lex1
  "abc sdf her"
  (word test-lex1::|abc| 1 1)
  (word test-lex1::|sdf| 1 5)
  (word test-lex1::|her| 1 9)
  (:eof nil 1 11))

(def-lexer-test lexer.2 'test-lex1
  "abcde
asdffgh dfghd adf
dsfg"
  (word test-lex1::|abcde| 1 1)
  (word test-lex1::|asdffgh| 2 1)
  (word test-lex1::|dfghd| 2 9)
  (word test-lex1::|adf| 2 15)
  (word test-lex1::|dsfg| 3 1)
  (:eof nil 3 4))


;; (deflexer signal
;;       (letter (:r #\A #\Z) :fragment)
;;       (digit (:r #\0 #\9) :fragment)
;;       (comma #\,)
;;       (l-s-br #\[)
;;       (r-s-br #\])
;;       (l-c-br #\()
;;       (r-c-br #\))
;;       (circum #\^)
;;       (slash #\/)
;;       (backslash #\\)
;;       (colon #\:)
;;       (semicolon #\;)
;;       (assing (#\: #\=))
;;       (two-dot "..")
;;       (dot #\.)
;;       (mul #\*)
;;       (and-o #\&)
;;       (mod "MOD")
;;       (add #\+)
;;       (sub #\-)
;;       (fract-des #\#)
;;       (not-o #\!)
;;       (less "<")
;;       (less-eq "<=")
;;       (eq "=")
;;       (not-eq "<>")
;;       (gr-eq ">=")
;;       (gr ">")
;;       (or "OR")
;;       (and "AND")
;;       (not "NOT")
;;       (do "DO")
;;       (to "TO")
;;       (endif "ENDIF")
;;       (else "ELSE")
;;       (then "THEN")
;;       (if "IF")
;;       (return "RETURN")
;;       (out "OUT")
;;       (in "IN")
;;       (link "LINK")
;;       (endcase "ENDCASE")
;;       (of "OF")
;;       (case "CASE")
;;       (endfor "ENDFOR")
;;       (for "FOR")
;;       (endloop "ENDLOOP")
;;       (loop "LOOP")
;;       (endwhile "ENDWHILE")
;;       (while "WHILE")
;;       (procedure "PROCEDURE")
;;       (deffunc "DEFFUNC")
;;       (ext "EXT")
;;       (blockfloat "BLOCKFLOAT")
;;       (float "FLOAT")
;;       (integer "INTEGER")
;;       (signal "SIGNAL")
;;       (var "VAR")
;;       (const "CONST")
;;       (begin "BEGIN")
;;       (end "END")
;;       (program "PROGRAM")
;;       (digits-string (:+ digit))
;;       (comment (#\( #\* (:*? :any) #\* #\)) :skip t)
;;       (identifier (letter (:* (:or letter digit))))
;;       (whitespace (:+ (:or #\Newline #\Space #\Return #\Vt #\Page #\Tab)) :skip t))

